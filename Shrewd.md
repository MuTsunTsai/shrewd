
# Shrewd 規格

Shrewd 是一個用於 TypeScript 前端開發專用的反應式框架。
Shrewd 的執行週期分成手動階段（manual stage）和認可階段（commiting stage）兩個階段。

- 在手動階段中，Shrewd 有如不存在一樣，此時若呼叫觀測者（雖然除了初始化反應方法之外不建議這麼做）會直接進行 top-down 的執行。
- 在認可階段中，會 bottom-up 地執行未更新的觀測者的操作。

## 可觀測物件（Observable）

- 可觀測物件會在自身狀態發生改變的時候對訂閱的觀測者發送通知。

## 自由物件（Independent）

- 可以被寫入的可觀測物件稱為自由物件。
- 自由物件只能在手動階段或者在稽核方法中被寫入，如果在其它情況中進行寫入，會忽略寫入並且在主控台中輸出警告。

## 觀測者（Observer）

- 觀測者在執行的時候會側錄執行過程中讀取可觀測物件的行為。
- 我們說一個觀測者處於活躍（active）狀態、如果這個觀測者是一個反應方法或者它目前有訂閱者的話。
- 活躍的觀測者會在讀取可觀測物件的時候對該物件進行訂閱。
- 活躍的觀測者在任何一次執行完畢都進入「已更新」狀態。
- 觀測者接到任何訂閱對象的新通知時變成「未更新」狀態，非活躍的觀測者不會解除此狀態。
- 觀測者在認可階段中只有在未更新的時候被呼叫會真的執行，如果已更新，則呼叫時會直接傳回暫存值。

## 可觀測屬性（ObservableProperty）

- 可觀測屬性是資料流的起點，任何手動階段中發生的變更都必須從這邊開始。
- 可觀測屬性中的原生類別內容會被遞迴地替換成自由物件。非原生類別因為無法知道其行為，不做任何替換。
- 可觀測物件可以指定稽核方法和渲染方法。

##### 稽核方法（validator）

- 稽核方法會在輸入的當下檢查輸入值是否有效並傳回一個 boolean 值。如果無效，會忽略輸入。
- 預設的稽核行為是一律有效。
- 稽核方法只有在手動階段中會被執行，而且不會訂閱參照過的可觀測物件。然後在一路呼叫的時候會確認目前的持有者正確）

##### 渲染方法（renderer）

- 渲染方法會根據一定的規則把輸入值轉變成輸出值。
- 渲染方法會對參照對象進行訂閱並且持續自動執行。
- 預設的渲染行為是原封不動地輸出。
- 渲染方法在執行的過程中允許對自己的內容中的自由物件進行寫入。

## 計算屬性（ComputedProperty）

- 計算屬性會根據一些可觀測物件進行計算而得到新的值。它是資料流的中間角色。
- 除非有接到訂閱對象通知，計算屬性會持續傳回暫存的計算結果而不會重新計算。

## 反應方法（ReativeMethod）

- 反應方法在概念上是資料流的終點，不過它仍然可以被其它觀測者呼叫（尤其是繼承類別中的同名方法）。
- 如果在手動階段中呼叫反應方法，會真的重新執行之。
- 由於呼叫它的觀測者有可能會使用到它或許會有的傳回值，因此任何觀測者只要有呼叫它都視為是有參照它，無論它是否有傳回值（畢竟或許沒有傳回值對呼叫它的觀測者來說也有其意義）。






## 問題

1. 變動參照：

如果任何一個操作 A 在執行時新觀測到了一個至少跟自己層級一樣高的可觀測物件 B，那麼由於 B 可能還沒執行過其實應該要執行的操作，
如果此時就先把 A 執行完畢，那麼 B 等一下要是執行了、而且還發生過變動，那麼在這同一個認可階段裡面 A 就會被執行兩次。

解決辦法：

- 不再使用相依層級的概念；認可動作從哪一個物件開始做都行。
- 把狀態區分成三種：已更新、可能需要更新、需要更新
- 當可觀測物件發出通知的時候，直屬下游觀測者變成需要更新，其餘全部下游物件如果是已更新狀態則變成可能需要更新
- 任何活躍的觀測者執行完畢都會變成已更新，非活躍物件執行完畢不改變狀態。
- 當觀測到一個未更新物件時：
  若為需要更新，且它全部的訂閱對象都已經更新，執行之。
  若為可能需要更新，且它全部的訂閱對象都已經更新，將它設定為已更新並忽略之。
  否則，往上游處理這個物件尚未更新的訂閱對象。